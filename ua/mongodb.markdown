 
\thispagestyle{empty}
\changepage{}{}{}{-1.5cm}{}{2cm}{}{}{}

![The Little MongoDB Book, By Karl Seguin](title.png)

\clearpage
\changepage{}{}{}{1.5cm}{}{-2cm}{}{}{}

## Про книгу ##

### Ліцензія ###
The Little MongoDB Book (Маленька книга про MongoDB) розповсюджується під ліцензією Attribution-NonCommercial 3.0 Unported. **Ви не повинні платити за цю книгу.**

Дозволяється вільно копіювати, розповсюджувати, змінювати або публікувати дану книгу. Однак, прошу завжди посилатися на автора - Karl Seguin - і не використовувати книгу в комерційних цілях.

Повний текст ліцензії завжди можна прочитати тут:

<http://creativecommons.org/licenses/by-nc/3.0/legalcode>

### Про автора ###
Karl Seguin - розробник з досвідом у багатьох областях і технологіях. Він є .NET- і Ruby-розробником з великим досвідом роботи.  Також бере участь у open-source проектах, є технічним письменником і нерегулярним доповідачем на конференціях. Стосовно до MongoDB, він був розробником ядра C# MongoDB бібліотеки NoRM, написав інтерактивний підручник [mongly](http://mongly.com) і [Mongo Web Admin](https://github.com/karlseguin/Mongo-Web-Admin). Його безкоштовний сервіс для розробників казуальних ігор, [mogade.com] (http://mogade.com/), працює на MongoDB.

Карл також написав книгу [The Little Redis Book](http://openmymind.net/2012/1/23/The-Little-Redis-Book/)

Ось його блог: <http://openmymind.net>, і твіттер: [@ karlseguin](http://twitter.com/karlseguin)

### Подяки ###
Особлива подяка [Perry Neal](http://twitter.com/perryneal) за розум, увагу і ентузіазм. Ти надав мені неоціненну допомогу. Дякую.

### Остання версія ###
Свіжі вихідні тексти книги доступні за адресою: 

<http://github.com/karlseguin/the-little-mongodb-book>.

## Про переклад ##

Переклав українською мовою [Павло Струбицький](https://github.com/vizaur).

\ Clearpage

## Вступ ##
> Не моя вина, що книга така коротка, просто MongoDB легка в освоєнні.

Технології розвиваються семимильними кроками. Список нових технологій і методологій постійно зростає. Однак, я завжди дотримувався думки, що фундаментальні технології, які використовують програмісти, розвиваються не настільки стрімко. Можна довгий час володіти актуальними знаннями, не поповнюючи їх. Однак найчастіше усталені технології замінюються іншими з вражаючою швидкістю. Раптові стрибки розробок іноді ставлять під загрозу усталені старі технології.

Яскравий приклад того - прогрес NoSQL-технологій, що приходять на заміну давно відомим реляційних баз даних. Вчора ще веб базувався на кількох відомих СУРБД, проте вже сьогодні з'явилося близько п'яти NoSQL-рішень, які гідно зарекомендовшіх себе.

Незважаючи на стрибкоподібність таких змін, на ділі можуть знадобитися роки, щоб вони увійшли в загальноприйняту практику. Початковий ентузіазм, як правило, охоплює невелике число розробників і компаній. Рішення відточуються, отримуються уроки, - і, бачачи, що нова технологія розвивається, решта пробують застосовувати її для своїх потреб. Знову ж таки, це стосується сфери NoSQL, де багато технологій є не стільки прямою заміною більш традиційних механізмів зберігання, скільки є рішеннями спеціальних проблем, на додаток до того, що можна очікувати від традиційних систем.

Беручи до уваги все вищевикладене, ми повинні усвідомити, чим же є NoSQL. Це широкий термін, який означає різне для різних людей. Особисто я використовую його в широкому сенсі, щоб позначити систему, що бере участь у зберіганні даних. З іншого боку NoSQL для мене означає переконаність у тому, що завдання зберігання даних не покладається на одну велику систему. В той час, як виробники більшості баз даних історично намагалися позиціонувати своє програмне забезпечення, як рішення «все в одному», NoSQL прагне до меншого рівня відповідальності - коли для певних завдань може бути обраний такий інструмент, який би вирішував саме цю задачу найкращим чином. Наприклад, ваш NoSQL-стек може ефективно використовувати реляційні бази даних, як наприклад MySQL, однак він також може включати в себе Redis - для організації зберігання записів key-value або Hadoop - для інтенсивної обробки даних. Простіше кажучи, NoSQL - це відкрита технологія, яка складається з альтернативних, існуючих і додаткових шаблонів управління даними.

Дивно, але MongoDB підходить під всі ці визначення. Як документ-орієнтована СУБД, Mongo - це досить-узагальнене NoSQL рішення. Її можна розглядати, як альтернативу реляційних СУБД. Подібно реляційним СУБД, вона також може виграшно доповнюватися більш спеціалізованими NoSQL рішеннями. У MongoDB є як переваги, так і недоліки, про них ми поговоримо в наступних частинах книги. 

Як ви вже помітили, терміни MongoDB і Mongo використовуються як синоніми.

## Приступаючи до роботи ##
Більша частина книги висвітлює базові можливості MongoDB. Тому нам знадобиться консоль MongoDB. Консоль буде використовуватися для навчальних і адміністративних завдань, а в коді ми будемо користуватися драйвером MongoDB.

Ми підійшли до першого, що треба знати про MongoDB: до її драйверів. У MongoDB є [багато офіційних драйверів](http://www.mongodb.org/display/DOCS/Drivers) для різних мов. Їх можна розглядати як драйвери вже звичних реляційних БД. На їх основі співтовариство розробників побудувало багато високорівневих драйверів - для певних мов і фреймворків. Наприклад, [NoRM](https://github.com/atheken/NoRM) це бібліотека для C#, що реалізує LINQ, а [MongoMapper](https://github.com/jnunemaker/mongomapper) для Ruby, з підтримкою ActiveRecord. Програмувати безпосередньо, використовуючи низькорівневі драйвери MongoDB, або ж із застосуванням високорівневих бібліотек - вирішуйте самі. Я детально зупинився на цьому, тому що багато новачків бувають збиті з пантелику наявністю як офіційних драйверів, так і розроблюваних спільнотою - перші націлені на базову комунікацію з Mongo, в той час як другі - більше на впровадження в конкретні мови і фреймворки.

У міру читання намагайтеся відтворювати демонстровані приклади, а також вивчати питання, які можуть при цьому виникнути. Підняти у себе MongoDB просто, нам знадобиться кілька хвилин, щоб все налаштувати. 

1. Зайдіть на [офіційну сторінку скачування](http://www.mongodb.org/downloads) і скачайте бінарні файли з першого рядка (рекомендовану стабільну версію) для операційної системи, яку ви використовуєте. Для розробки можна використовувати як 32 -, так і 64-розрядну версію.

2. Розпакуйте архів (куди завгодно) і перейдіть в папку `bin`. Поки нічого не запускайте, але запам'ятайте, що `mongod` - це сервер, а `mongo` - клієнтська консоль - ось два виконуваних файлу, з якими нам найчастіше доведеться працювати.

3. Створіть новий файл в папці `bin` і назвіть його `mongodb.config`

4. Додайте в mongodb.config один рядок: `dbpath=ШЛЯХ_КУДИ_ХОЧЕТЕ_ЗБЕРЕГТИ_ФАЙЛИ_БАЗИ_ДАНИХ`. Наприклад, в Windows можна написати `dbpath=c:\mongodb\data` а в Linux - `dbpath=/etc/mongodb/data`.

5. Переконайтеся, що вказаний вами шлях `dbpath` існує.

6. Запустіть mongod з параметром `--config /path/to/your/mongodb.config`.

Для користувачів Windows, наприклад, якщо ви розпакували скачаний файл в `c:\mongodb\` і створили папку `c:\mongodb\data\`, то в `c:\mongodb\bin\mongodb.config` слід вказати `dbpath=c:\mongodb\data\`. Тепер можна запускати `mongod` з командного рядка за допомогою команди `c:\mongodb\bin\mongod --config c:\mongodb\bin\mongodb.config`.

Папку `bin` можна для зручності додати в змінну оточення `PATH`. Для користувачів MacOSX і Linux інструкції практично ті ж самі. Все, що потрібно зробити - це просто змінити шляхи.

Сподіваюся, тепер MongoDB у вас встановлена ​​і запущена. Якщо є помилки - уважно читайте повідомлення в консолі - сервер детально і ясно виводить діагностичні повідомлення.

Тепер, щоб підключитися до запущеного сервера, можете запустити `mongo` (без *d* в кінці). Спробуйте ввести `db.version()`, щоб переконатися, що все в порядку. Якщо все нормально - ви побачите номер версії вашого сервера.

\ Clearpage

## Глава 1 - Основи ##
Почнемо ми з вивчення основних механізмів роботи з MongoDB. Це саме основне, що знадобиться для розуміння MongoDB, але також ми торкнемося високорівневих питань - про те, де застосовується MongoDB.

Для початку потрібно зрозуміти шість основних концепцій.

1. MongoDB - концептуально те ж саме, що звичайна, звична нам база даних (або в термінології Oracle - схема).  У середині MongoDB може бути нуль або більше баз даних, кожна з яких є контейнером для інших сутностей.

2. База даних може мати нуль або більше 'колекцій'. Колекція настільки схожа на традиційну 'таблицю', що можна сміливо вважати їх одним і тим же.

3 Колекції складаються з нуля або більше 'документів'. Знову ж таки, документ можна розглядати як 'рядок'.

4. Документ складається з одного або більш 'полів', які - як можна здогадатися - подібні до 'колонок'.

5. 'Індекси' в MongoDB майже ідентичні таким в реляційних базах даних.

6. 'Курсори' відрізняються від попередніх п'яти концепцій, але вони дуже важливі (хоча часом їх обходять увагою) і заслуговують окремого обговорення.  Важливо розуміти, що коли ми запитуємо у MongoDB які-небудь дані, то вона повертає курсор, з якими ми можемо робити все що завгодно - підраховувати, пропускати певну кількість попередніх записів - при цьому не завантажуючи самі дані.

Підводячи підсумок, MongoDB складається з `баз даних`, які складаються з `колекцій`. `Колекції` складаються з `документів`. Кожен `документ` складається з `полів`. `Колекції` можуть бути проіндексовані, що покращує продуктивність вибірки та сортування. І нарешті, отримання даних з MongoDB зводиться до отримання `курсора`, який віддає ці дані при потребі.

Ви можете запитати - навіщо придумувати нові терміни (колекція замість таблиці, документ замість запису і поле замість колонки)? Чи не зайве це ускладнення? Відповідь у тому, що ці терміни, хоч і близькі до своїх «реляційних» аналогів, але не повністю ідентичні їм. Основна відмінність в тому, що реляційні бази даних визначають «колонки» на рівні `таблиці`, в той час як документ-орієнтовані бази даних визначають «поля» на рівні `документу`. Це означає, що будь-який документ у середині колекції може мати свій власний унікальний набір полів.  У цьому сенсі `колекція` «дурніша» від `таблиці`, тоді як `документ` має набагато більше інформації, ніж `рядок`.

Хоч це і важливо зрозуміти, не хвилюйтеся, якщо не зможете відразу. Після декількох вставок ви побачите, що мається на увазі. У кінцевому рахунку справа в тому, що колекція не містить інформації про структуру даних, які в ній містяться. Інформацію про поля містить кожен окремий документ. Переваги та недоліки цього стануть зрозумілі з наступної глави.

Приступимо. Запустіть сервер `mongod` і консоль `mongo`, якщо ще не запустили. Консоль працює на JavaScript. Є кілька глобальних команд, наприклад `help` або `exit`. Команди, які ви запускаєте стосовно до поточної базі даних виконуються в об'єкта `db`, наприклад `db.help()` або `db.stats()`. Команди, які ви запускаєте стосовно конкретної колекції, виконуються в об'єкта `db.ІМ'Я_КОЛЛЕКЦІІ `, наприклад` db.unicorns.help() `або` db.unicorns.count()`.

Введіть `db.help()` і отримаєте список команд, які можна виконати в об'єкта `db`.

Замітка на полях. Оскільки консоль інтерпретує JavaScript, якщо ви спробуєте виконати метод без дужок, то у відповідь отримаєте тіло методу, але він не виконається. Не дивуйтеся, побачивши `function(...) {`, якщо випадково зробите так. Наприклад, якщо введете `db.help` (без дужок), ви побачите внутрішнє представлення методу `help`.

Спершу для вибору бази даних скористаємося глобальним методом `use` - введіть `use learn`. Неважливо, що база даних поки що не існує. В момент створення першої колекції створиться база даних `learn`. Тепер, коли ви всередині бази даних, можна викликати у неї команди, наприклад `db.getCollectionNames()`. У відповідь побачите порожній масив (`[]`). Оскільки колекції безструктурні *(в оригіналі «schema-less». Тут і далі - прим. перекл.)*, ми не зобов'язані створювати їх явно. Ми просто можемо вставити документ в нову колекцію. Щоб це зробити, використовуйте команду `insert`, передавши їй документ, який вставляється:

	db.unicorns.insert({name: 'Aurora', gender: 'f', weight: 450})

Даний рядок виконує метод `insert` («вставити») в колекцію `unicorns`, передаючи йому єдиний аргумент. MongoDB у себе всередині використовує бінарний серіалізірованний JSON формат. Зовні це означає, що ми широко використовуємо JSON, як, наприклад, у випадку з нашими параметрами. Якщо тепер виконати `db.getCollectionNames()`, ми побачимо дві колекції: `unicorns` і `system.indexes`. `System.indexes` створюється в кожній базі даних і містить в собі інформацію про індекси цієї бази. 

Тепер у колекції `unicorns` можна викликати метод `find`, який поверне список документів:

	db.unicorns.find()

Зауважте, що окрім даних, які ми ставили, з'явилося додаткове поле `_id`. Кожен документ повинен мати унікальне поле `_id`. Можете генерувати його самі або дозволити MongoDB самої згенерувати для вас ObjectId. У більшості випадків ви швидше за все спровадите цю задачу на MongoDB. За замовчуванням `_id` - індексовані поле, внаслідок чого і створюється колекція `system.indexes`. Давайте поглянемо на `system.indexes`:

	db.system.indexes.find()

Ви побачите ім'я індексу, бази даних і колекції, для якої індекс був створений, а також полів, які включені в нього.

Повернемося до обговорення безструктурних колекцій. Давайте вставимо кардинально відмінний від попереднього документ в `unicorns`, ось такий:

	db.unicorns.insert({name: 'Leto', gender: 'm', home: 'Arrakeen', worm: false})

І знову скористаємося `find` для перегляду списку документів. Тепер, дізнавшись трохи більше, ми можемо обговорити цю цікаву поведінку MongoDB, але, сподіваюся, ви вже починаєте розуміти, чому традиційна термінологія тут не зовсім застосовна.

### Освоюємо селектори ###
На додаток до вивчених раніше шести концепцій, є ще один важливий практичний аспект MongoDB, який слід засвоїти, перш ніж переходити до більш складних тем: це - селектори запитів. Селектор запитів MongoDB аналогічний пропозиції `where` SQL-запиту. Як такий він використовується для пошуку, підрахунку, оновлення і видалення документів з колекцій. Селектор - це JSON-об'єкт, в простому випадку це може бути навіть `{}`, що означає вибірку всіх документів (аналогічним чином працює `null`). Якщо нам потрібно вибрати всіх єдинорогів (англ. «unicorns») жіночого роду, можна скористатися селектором `{gender: 'f'}`.

Перш, ніж ми глибоко поринемо в селектори, давайте спочатку створимо трохи даних, з якими будемо експериментувати. Спершу давайте видалимо все, що до цього вставляли в колекцію `unicorns` за допомогою команди: `db.unicorns.remove()` (оскільки ми не передали селектора, відбудеться видалення всіх документів). Тепер давайте проведемо наступні вставки, щоб отримати дані для подальших експериментів (можете скопіювати і вставити це в консоль):

	db.unicorns.insert({name: 'Horny', dob: new Date(1992,2,13,7,47), loves: ['carrot', 'papaya'], weight: 600, gender: 'm' , vampires: 63});
	db.unicorns.insert({name: 'Aurora', dob: new Date(1991, 0, 24, 13, 0), loves: ['carrot', 'grape'], weight: 450, gender: 'f' , vampires: 43});
	db.unicorns.insert({name: 'Unicrom', dob: new Date(1973, 1, 9, 22, 10), loves: ['energon', 'redbull'], weight: 984, gender: 'm' , vampires: 182});
	db.unicorns.insert({name: 'Roooooodles', dob: new Date(1979, 7, 18, 18, 44), loves: ['apple'], weight: 575, gender: 'm', vampires: 99 });
	db.unicorns.insert({name: 'Solnara', dob: new Date(1985, 6, 4, 2, 1), loves: ['apple', 'carrot', 'chocolate'], weight: 550, gender : 'f', vampires: 80});
	db.unicorns.insert({name: 'Ayna', dob: new Date(1998, 2, 7, 8, 30), loves: ['strawberry', 'lemon'], weight: 733, gender: 'f' , vampires: 40});
	db.unicorns.insert({name: 'Kenny', dob: new Date(1997, 6, 1, 10, 42), loves: ['grape', 'lemon'], weight: 690, gender: 'm' , vampires: 39});
	db.unicorns.insert({name: 'Raleigh', dob: new Date(2005, 4, 3, 0, 57), loves: ['apple', 'sugar'], weight: 421, gender: 'm' , vampires: 2});
	db.unicorns.insert({name: 'Leia', dob: new Date(2001, 9, 8, 14, 53), loves: ['apple', 'watermelon'], weight: 601, gender: 'f' , vampires: 33});
	db.unicorns.insert({name: 'Pilot', dob: new Date(1997, 2, 1, 5, 3), loves: ['apple', 'watermelon'], weight: 650, gender: 'm' , vampires: 54});
	db.unicorns.insert({name: 'Nimue', dob: new Date(1999, 11, 20, 16, 15), loves: ['grape', 'carrot'], weight: 540, gender: 'f' });
	db.unicorns.insert({name: 'Dunx', dob: new Date(1976, 6, 18, 18, 18), loves: ['grape', 'watermelon'], weight: 704, gender: 'm' , vampires: 165});

Тепер, коли дані створені, можна приступати до освоєння селекторів. `{Поле: значення}` використовується для пошуку всіх документів, у яких `поле` рівне `значення`. `{Поле1: значення1, поле2: значення2}` працює як логічне `І`. Спеціальні оператори `$lt`, `$lte`, `$gt`, `$gte` і `$ne` використовуються для вираження операцій «менше», «менше або дорівнює», «більше», «більше або дорівнює», і «не дорівнює». Наприклад, щоб отримати всіх самців єдинорога, що важать більше 700 фунтів, ми можемо написати:

	db.unicorns.find({gender: 'm', weight: {$gt: 700}})
	// або (що не повністю еквівалентно, але наведено тут у демонстраційних цілях)
	db.unicorns.find({gender: {$ne: 'f'}, weight: {$gte: 701}})

Оператор `$exists` використовується для перевірки наявності або відсутності поля, наприклад:

	db.unicorns.find({vampires: {$exists: false}})

Поверне єдиний документ. Якщо потрібно АБО замість І, ми можемо використовувати оператор `$or` і присвоїти йому масив значень, наприклад:

	db.unicorns.find({gender: 'f', $or: [{loves: 'apple'}, {loves: 'orange'}, {weight: {$lt: 500}}]})

Вищевказаний запит поверне всіх самок єдинорогів, які або люблять яблука, або люблять апельсини, чи важать менше 500 фунтів.

У нашому останньому прикладі відбулося дещо цікаве. Ви помітили - поле `loves` це масив. MongoDB підтримує масиви як об'єкти першого класу. Це приголомшливо зручна можливість. Почавши це використовувати, ви здивуєтеся, як ви раніше жили без цього. Найцікавіше це та простота, з якою робиться вибірка за значенням масиву: `{loves: 'watermelon'}` поверне нам усі документи, у яких `watermelon` є одним із значень поля `loves`.

Це ще не всі оператори. Найгнучкіший оператор - `$where`, що дозволяє нам передавати JavaScript для його виконання на сервері. Це описано в розділі [Складні запити](http://ru.wiki.mongodb.org/display/DOCS/Advanced+Queries) на сайті MongoDB. Ми вивчили основи, які нам потрібні для початку роботи. Це також те, що ви будете використовувати більшу частину часу.

Ми бачили, як ці селектори можуть бути використані з командою `find`. Вони також можуть бути використані з командою `remove`, яку ми коротко розглянули, командою `count`, яку ми покищо не розглянули, але яку ви швидше за все вивчите, і командою `update`, з якої в подальшому ми проведемо велику частину часу .

`ObjectId`, згенерований MongoDB для поля `_id`, підставляється в селектор таким чином:

	db.unicorns.find({_id: ObjectId("TheObjectId")})

### У цій главі ###
Ми поки ще не розглядали команду `update` або більш цікаві речі, які можна зробити за допомогою `find`. Однак ми підняли MongoDB, коротко вивчили команди `insert` і `remove` (вивчивши практично все, що про них можна вивчити). Ми також почали досліджувати `find` і дізналися що таке селектори MongoDB. Це непогано для початку, і закладено основи для подальшого вивчення. Вірите чи ні, але ви вже вивчили практично все, що потрібно знати про MongoDB - настільки вона проста і легка у вивченні. Я настійно рекомендую вам поекспериментувати з вашими даними, перш, ніж можна почнете рухатися далі. Вставте кілька нових документів - можливо в нові колекції - і поекспериментуйте з селекторами. Використовуйте `find`, `count` і `remove`. Після кількох ваших власних спроб речі, що здавалися незрозумілими, стануть на свої місця.

\ Clearpage

## Глава 2 - Оновлення ##
У першому розділі ми вивчили три з чотирьох операцій CRUD (create, read, update and delete). Ця глава присвячена четвертій: `update`. У `update` є деякі особливості, ось чому ми присвячуємо цьому цілий розділ.

### Оновлення даних: заміна і $set ###
У простій формі, `update` приймає 2 аргументи: селектор (where) для вибірки і те, чим оновити відповідне поле. Щоб Roooooodles додав у вазі, використовуємо наступний запит:

	db.unicorns.update({name: 'Roooooodles'}, {weight: 590})

(Якщо в ході експериментів ви видалили дані з раніше створеної колекції `unicorns`, зробіть всім документам `remove`, і вставте їх заново за допомогою коду з глави 1)

У реальному житті, звичайно, слід оновлювати документи, вибираючи їх за `_id`, однак, оскільки я не знаю який `_id` MongoDB згенерувала для вас, будемо вибирати за іменем - `name`.  Тепер, давайте поглянемо на оновлений запис:

	db.unicorns.find({name: 'Roooooodles'})

Ось і перший сюрприз, який нам підніс `update`. Документ не знайдений, оскільки другий параметр використовується для **повної заміни** оригіналу. Іншими словами, `update` знайшов документ за ім'ям і замінив його повністю новим документом (свій другий параметр). Ось у чому відмінність від SQL-команди `UPDATE`. Іноді це ідеальний варіант, який може використовуватися для деяких дійсно динамічних оновлень. Однак, якщо вам потрібно лише змінити декілька полів, краще за все використовувати модифікатор `$set`:

	db.unicorns.update({weight: 590}, {$set: {name: 'Roooooodles', dob: new Date(1979, 7, 18, 18, 44), loves: ['apple'], gender: ' m ', vampires: 99}})

Це відновить загублені раніше поля. Поле `weight` не перезапише, оскільки ми його не передали в запит. Тепер, якщо виконати:

	db.unicorns.find({name: 'Roooooodles'})

ми отримаємо очікуваний результат. Таким чином, у першому прикладі правильно було б оновити `weight` наступним чином:

	db.unicorns.update({name: 'Roooooodles'}, {$set: {weight: 590}})

### Модифікатори поновлення ###
Крім `$set` можна використовувати й інші модифікатори для різних витончених речей. Всі ці модифікатори поновлення діють над полями - так що ваш документ не опиниться перезаписаний цілком. Наприклад, модифікатор `$inc` служить для того, щоб змінити поле на додатню (збільшити) або від'ємну (зменшити) величину. Наприклад, якщо єдиноріг Pilot був помилково нагороджений за вбивство кількох зайвих вампірів, ми можемо виправити цю помилку в такий спосіб:

	db.unicorns.update({name: 'Pilot'}, {$inc: {vampires: -2}})

Якщо Aurora раптово пристрастилася до солодощів, ми можемо додати відповідне значення до її поля `loves` за допомогою модифікатора `$push`:

	db.unicorns.update({name: 'Aurora'}, {$push: {loves: 'sugar'}})

Інформацію про решту модифікаторах можна знайти в розділі [Оновлення](http://ru.wiki.mongodb.org/display/DOCS/Updating) на сайті MongoDB.

### Оновлення / вставка ###
Один з приємних сюрпризів операції оновлення - це можливість оновлення / вставки *(`upsert` від `update` - оновити і `insert` - вставити)* Оновлення / вставка оновлює документ, якщо він знайдений, або створює новий - якщо не знайдений. Оновлення / вставка - корисна річ в деяких випадках; коли зіткнетеся з подібним, відразу зрозумієте. Щоб дозволити вставку при оновленні, встановіть третій параметр в `true`.

Приклад з життя - лічильник відвідувань для веб-сайту. Якщо ми хочемо в реальному часі бачити кількість відвідувань сторінки, ми повинні подивитися, чи існує запис, і - залежно від результату - виконати `update` або `insert`. Якщо опустити (або встановити в `false`) третій параметр, наступний приклад не спрацює:

	db.hits.update({page: 'unicorns'}, {$inc: {hits: 1}});
	db.hits.find();

Однак, якщо дозволити вставку при оновленні, результати будуть іншими:

	db.hits.update({page: 'unicorns'}, {$inc: {hits: 1}}, true);
	db.hits.find();

Оскільки документи з полем `page`, рівним `unicorns`, не існують, то буде створено новий документ. Якщо виконати це поаторно, існуючий документ буде оновлено, і поле `hits` збільшиться до 2.

	db.hits.update({page: 'unicorns'}, {$inc: {hits: 1}}, true);
	db.hits.find();

### Множинні поновлення ###
Останній сюрприз методу `update` - це, те що він за замовчуванням оновлює лише один документ. До цих пір це було логічно у випадку з вже розглянутими прикладами. Однак, якщо виконати щось на кшталт:

	db.unicorns.update({}, {$set: {vaccinated: true}});
	db.unicorns.find({vaccinated: true});

, То ви очевидно будете очікувати, що всі єдинороги будуть щеплені *(`vaccinated`)*. Щоб це спрацювало, потрібно встановити четвертий параметр в `true`:

	db.unicorns.update({}, {$set: {vaccinated: true}}, false, true);
	db.unicorns.find({vaccinated: true});

### У цій главі ###
Ця глава завершила вступ в основні CRUD операції над колекціями. Ми детально розглянули `update` і побачили три його цікавих режими роботи. По-перше, на відміну від SQL-команди `UPDATE`, в MongoDB `update` замінює документ цілком. Через це модифікатор `$set` дуже корисний. По-друге, `update` підтримує інтуїтивно просте оновлення / вставку, яке особливо корисно з модифікатором `$inc`. І, нарешті, по-третє, за замовчуванням, `update` оновлює лише перший знайдений документ.

Пам'ятайте, що ми розглядаємо MongoDB з точки зору її консолі. Використовувані вами драйвери і бібліотеки можуть мати іншу поведінку і реалізовувати інший API. Наприклад, драйвер для Ruby зливає два параметри в один хеш: `{: upsert => false,: multi => false}`.

\ Clearpage

## Глава 3 - Освоюємо Find ##
У главі 1 ми коротенько розглянули команду `find`. Однак, `find` - це не тільки селектори. Як уже згадувалося, результатом `find` є курсор. Настав час розглянути це детальніше.

### Вибір полів ###
Перш ніж переходити до курсорів, слід знати, що `find` приймає другий необов'язковий параметр. Це - список полів, які ми хочемо отримати. Наприклад, ми можемо отримати всі імена єдинорогів наступним запитом:

	db.unicorns.find(null, {name: 1});

Поле `_id` за замовчуванням повертається завжди. Ми можемо явним способом виключити його, вказавши `{name:1, _id: 0}`.

За винятком поля `_id`, не можна змішувати включення і виключення полів. Замислившись, можна зрозуміти, навіщо так зроблено. Можна або хотіти включити або хотіти навпаки - виключити певні поля явним чином.

### Сортування ###
Я вже кілька разів згадав, що `find` повертає курсор, який виконується відкладено - в міру необхідності. Однак, ви вже без сумніву могли бачити, що `find` виконуюється миттєво. Така поведінка характерна тільки для консолі. Можна поспостерігати за істинною поведінкою курсорів, поглянувши на будь-який з методів, який ми можемо приєднати до `find`. Першим з них буде `sort`. Синтаксис `sort` приблизно такий же, як у вибору полів, який ми бачили в попередньому розділі. Ми вказуємо поля, за якими потрібно сортувати, використовуючи `1` для сортування за зростанням і `-1` для сортування за спаданням. Наприклад,

	// Сортуємо за вагою - від важких до легких єдинорогів
	db.unicorns.find().sort({weight: -1})
	// За іменем єдинорога, потім за кількістю вбитих вампірів:
	db.unicorns.find().sort({name: 1, vampires: -1})

Подібно до реляційної бази даних, MongoDB може використовувати індекси для сортування. Детальніше ми розглянемо індекси дещо пізніше. Однак варто знати, що без індексу MongoDB обмежує розмір сортовані даних. Якщо ви спробуєте відсортувати великий обсяг даних, не використовуючи індекс, ви отримаєте помилку. Деякі вважають це обмеженням. Хоча я думаю, що й іншим баз даних не завадило б забороняти виконання неоптимальних запитів. (Я не стану перетворювати кожен недолік MongoDB в її перевагу, проте я стикався з великою кількістю неоптимальних баз даних, яким дуже не вистачало подібного режиму суворої перевірки.)

### Розбиття на сторінки ###
Розбиття на сторінки може бути здійснено за допомогою методів `limit` і `skip`. Щоб отримати другого і третього за вагою єдинорога, можна виконати:

	db.unicorns.find().sort({weight: -1}). limit(2). skip(1)

Використовуючи `limit` разом з `sort` можна уникнути проблем з сортуванням за неіндексованими полям.

### Count ###
Консоль дозволяє виконати `count` прямо над колекцією:

	db.unicorns.count({vampires: {$gt: 50}})

На практиці ж `count` - це метод курсору, консоль просто забезпечує зручне скорочення. З драйверами, що не підтримують подібного скорочення, потрібно писати щось на зразок цього (звичайно, і в консолі теж так можна):

	db.unicorns.find({vampires: {$gt: 50}}).count()

### У цій главі ###
Досить просто користуватися `find` і курсорами. Є ще кілька додаткових команд, які ми або розглянемо пізніше, або не розглянемо взагалі (так як вони застосовуються лише в граничних випадках), але тепер, я думаю, ви повинні вже освоїтися в роботі з консоллю `mongo` і розумінням основних принципів MongoDB.

\ Clearpage

## Глава 4 - Моделювання даних ##
Давайте змінимо тему і поговоримо про більш абстрактні концепції MongoDB. Досить просто пояснювати нові терміни і новий синтаксис. Набагато складніше говорити про моделювання в термінах нової парадигми. Сенс у тому, що більшість з нас звикли пробувати будь-яку нову технологію, моделюючи реальні завдання. Ми поговоримо про це, але в кінцевому рахунку ви повинні попрактикуватися і вивчити реальний код.

Коли мова заходить про моделювання даних, то документ-орієнтовані бази даних не настільки сильно відрізняються від реляційних, як інші NoSQL-рішення. Існуючі відмінності не настільки великі, проте це не зменшує їхньої важливості. 

### Відсутність JOIN-ов ###
Перша і сама фундаментальна відмінність, до якої вам потрібно звикнути, це відсутність у MongoDB аналога конструкції JOIN. Невідомо чому саме MongoDB не підтримує JOIN-синтаксису, однак точно можна сказати, що JOIN-и не масштабуються. Це означає, що коли ви почнете розділяти дані горизонтально, вам все одно доведеться виконувати JOIN-и на клієнті (яким є сервер додатків). Незалежно від причин, факт залишається фактом: дані реляційні за своєю природою, але MongoDB не підтримує JOIN-ів.

Ми повинні робити JOIN-и вручну, в коді свого застосування. По суті, ми повинні робити другий запит, щоб знайти пов'язані дані. Створення даних тут не сильно відрізняється від створення зовнішніх ключів в реляційних базах. Тепер давайте від єдинорогів (`unicorns`) перейдемо до співробітників (`employees`). Першим ділом створимо співробітника (я явним чином наводжу тут `_id`, щоб наші приклади виконувалися як задумано)

	db.employees.insert({_id: ObjectId("4d85c7039ab0fd70a117d730"), name: 'Leto'})

Тепер додамо пару співробітників і зробимо `Leto` їх менеджером:

	db.employees.insert({_id: ObjectId("4d85c7039ab0fd70a117d731"), name: 'Duncan', manager: ObjectId ("4d85c7039ab0fd70a117d730")});
	db.employees.insert({_id: ObjectId("4d85c7039ab0fd70a117d732"), name: 'Moneo', manager: ObjectId ("4d85c7039ab0fd70a117d730")});

(Варто повторити, що `_id` може бути будь-яким унікальним значенням. Оскільки в житті ви швидше за все станете використовувати `ObjectId`, ми також тут використовуємо його.)

Щоб знайти всіх співробітників, що належать Leto, виконаємо просто:

	db.employees.find({manager: ObjectId("4d85c7039ab0fd70a117d730")})

Ніякої магії. У гірших випадках відсутність JOIN-ів найчастіше потребує додаткового запиту (як правило індексованого).

#### Масиви і вкладені документи ####
Але той факт, що у MongoDB немає JOIN-ів ще не означає, що у неї не припасено пару козирів у рукаві. Пам'ятаєте, як ми коротенько розповіли раніше про підтримку в MongoDB масивів, як об'єктів першого класу? Виявляється, що це досить зручно, коли потрібно змоделювати відношення «один-до-багатьох» або «багато-до-багатьох». Наприклад, якщо у співробітника є декілька менеджерів, ми просто можемо зберегти їх у вигляді масиву:

	db.employees.insert({_id: ObjectId("4d85c7039ab0fd70a117d733"), name: 'Siona', manager: [ObjectId ("4d85c7039ab0fd70a117d730"), ObjectId ("4d85c7039ab0fd70a117d732")]})

А найцікавіше, що в одних документах `manager` можна зробити скалярним значенням, а в інших - масивом. А наш попередній запит `find` спрацює в обох випадках:

	db.employees.find({manager: ObjectId("4d85c7039ab0fd70a117d730")})

Невдовзі ви переконаєтесь, що масиви значень набагато зручніші у використанні, ніж таблиці зв'язку «багато-до-багатьох».

Крім масивів MongoDB також підтримує вкладені документи. Спробуйте вставити документ зі вкладеним документом, наприклад:

	db.employees.insert({_id: ObjectId("4d85c7039ab0fd70a117d734"), name: 'Ghanima', family: {mother: 'Chani', father: 'Paul', brother: ObjectId("4d85c7039ab0fd70a117d730")}})

Вкладені документи можна запитувати за допомогою точкової нотації:

	db.employees.find({'family.mother': 'Chani'})

Ми коротко обговоримо, де можуть використовуватися вкладені документи, і як їх слід застосовувати.

#### DBRef ####
MongoDB підтримує поняття під назвою `DBRef`, яке є угодою, прийнятою в багатьох драйверах. Коли драйвер бачить `DBRef`, він може автоматично отримати пов'язаний документ. `DBRef` включає в себе колекцію і `_id` документа, на який він посилається. Це означає наступне - документи з однієї і тієї ж колекції можуть посилатися на інші документи з різних колекцій. Тобто документ 1 може посилатися на документ з колекції `managers`, в той же час документ 2 може посилатися на документ з колекції `employees`.


#### Денормализация ####
Ще одна альтернатива використанню JOIN-ів - денормализация. Історично денормализация використовувалася для оптимізації продуктивності, або коли з даних (наприклад, журналу аудиту) необхідно було мати можливість робити знімок. Однак зі швидким ростом NoSQL рішень, більшість з яких позбавлені JOIN-ов, денормализация стала нормальним явищем. Це не означає, що потрібно дублювати все підряд в будь-яких документах. Можна остерігатися дублювання даних, а можна відповідним чином продумати архітектуру своєї бази.

Наприклад, ми розробляємо форум. Традиційний шлях асоціювати користувача з його постом - це колонка `userid` в таблиці `posts`. з такою моделлю не можна відобразити список постів без додаткового добування даних (JOIN) з таблиці користувачів. Можливе рішення - зберігати ім'я користувача (`name`) разом з `userid` для кожного поста. Можна також вставляти невеликий вбудований документ, наприклад, `user: {id: ObjectId('Something'), name: 'Leto'}`. Так, якщо дозволити користувачам змінювати своє ім'я, нам доведеться оновлювати кожен документ (пост) - це один зайвий запит. 

Не всім легко пристосуватися до такого підходу. У багатьох випадках навіть не має сенсу це робити. Все ж не бійтеся експериментувати з таким підходом. Іноді це буває корисним - чи не єдиним правильним - рішенням.

#### Що вибрати? ####
Також корисною стратегією у випадках відношення «один-до-багатьох» або «багато-до-багатьох» є масив ідентифікаторів. Існує думка, що `DBRef` використовується не так часто, але звичайно ви можете поекспериментувати з ним. Зазвичай початкуючі розробники не впевнені що підійде їм краще - вкладені документи чи `DBRef`.

По-перше, слід пам'ятати, що одиночний документ обмежений в розмірі до 4 мегабайт. Факт обмеження (нехай і такого щедрого) розміру документу дає розуміння про те, як їх потрібно використовувати. Тепер зрозуміло, що більшість розробників схиляються до використання заданих вручну посилань. Вкладені документи використовуються часто, але для невеликих обсягів даних, якщо їх бажано завжди витягувати разом з батьківським документом. Прикладом з життя може бути документ `accounts`, зберігається з кожним користувачем, наприклад:

	db.users.insert({name: 'leto', email: 'leto@dune.gov', account: {allowed_gholas: 5, spice_ration: 10}})

Це не означає, що можна недооцінювати потужність вкладених документів, або відкидати їх, як дрібну, другорядну утиліту. Набагато простіше живеться, коли структура ваших даних безпосередньо відображає структуру ваших об'єктів. Особливо цінним є те, що MongoDB дозволяє запитувати і індексувати поля вкладених документів. 

### Мало чи багато колекцій ###
Враховуючи те, що колекції не прив'язують нас до конкретної схеми, цілком можливо обійтися однією колекцією, яка має документи різної структури.  Побудовані на MongoDB системи, з якими мені доводилося стикатися, як правило, були схожі на реляційні бази даних. Іншими словами, те, що було б таблицею в реляційній базі даних, швидше за все реалізується, як колекція в MongoDB (таблиці-зв'язки «багато-до-багатьох» є важливим винятком).

Справа приймає цікавий оборот, якщо скористатися вкладеними документами. Приклад, який відразу пригадується, це блог. Припустимо, є колекція `posts` і колекція `comments`, і кожен пост повинен мати вкладений масив коментарів. Якщо залишити осторонь обмеження 4Мб («Гамлет» англійською ледве дотягує до 200 кілобайт, наскільки ж повинен бути популярним ваш блог?), Більшість розробників вважають за краще розділяти сутності. Так зрозуміліше і ясніше.

Немає будь-якого строгого правила (ну, крім 4MB). Поекспериментуйте з різними підходами, і вам стане ясно, що буде правильніше, а що - ні.

### У цій главі ###
Метою цієї глави було представити деякі корисні рекомендації для моделювання даних в MongoDB. Якщо завгодно, стартову точку. Моделювання в документ-орієнтованих системах відрізняється від такого в реляційних, але не так вже сильно. Тут набагато більше гнучкості, але є одне обмеження, хоча для розробки нової системи це підходить, як правило, непогано. Не виходить тільки у тих, хто не пробує.

\ Clearpage

## Глава 5 - Коли використовувати MongoDB ##
До цього моменту у вас має сформуватися розуміння MongoDB, достатню для того, щоб зрозуміти, де вона може вписатися в вашу існуючу систему. Є так багато нових, конкуруючих технологій зберігання даних, що легко розгубитися у виборі, яку ж з них використовувати. 

Для мене найбільшим уроком, який не має, втім, нічого спільного з MongoDB, стало те, що не обов'язково покладатися на єдине рішення для роботи з даними. Природно, єдине рішення має очевидні переваги, і для багатьох - якщо не для більшості - проектів таке є розумним підходом. Сенс не в тому, що ви *повинні*, а скоріше в тому, що ви *можете* використовувати різні технології. Тільки ви знаєте, чи переважують переваги від впровадження нового рішення можливі витрати.

З урахуванням сказаного, я сподіваюся, що бачене вами раніше дозволило вам розцінювати MongoDB в якості загального рішення. Пару раз згадувалося, що документ-орієнтовані бази даних мають багато спільного з реляційними. Таким чином, щоб не ходити кругами, дозвольте просто заявити, що MongoDB може розглядатися як пряма альтернатива реляційних баз даних. В той час, як Lucene можна розглядати, як розширення реляційних баз повнотекстових індексом, а Redis - як персистентне сховище ключ-значення, MongoDB - це центральний репозиторій для ваших даних.

Зауважте, я не називаю MongoDB *заміною* реляційних баз, це скоріше *альтернатива*. Це інструмент, який може робити те ж, що можуть робити багато інших. Дещо - краще, дещо - ні. Проаналізуємо це трохи пізніше.

### Безструктурність ###
Часто рекламованою перевагою документ-орієнтованих баз даних є те, що вони безструктурні. Це робить їх набагато більш гнучкими, ніж традиційні реляційні бази даних. Я згоден, що безструктурність хороша, але тільки не в якості згадуваної багатьма головної переваги.

Часто безструктурність бачиться як хаотична організація даних. Є домени і набори даних, які і справді дуже важко змоделювати в термінах звичайної реляційної бази даних, але я розглядаю їх швидше як граничні випадки. Безструктурність приваблива, проте велика частина даних повинна бути добре структурованою. Звичайно, іноді це може бути зручно, особливо для додавання нового функціоналу, однак на ділі це можна вирішити і додаваннями нових необов'язкових полів.

Для мене справжня перевага безструктурної архітектури - це відсутність установки і зведення до мінімуму розбіжності з ООП. Особливо це відчувається при роботі із статично типізованими мовами. Я працював з MongoDB як в C#, так і в Ruby - різниця впадає в очі. Динамізм Ruby і популярна реалізація ActiveRecord вже відчутно скорочують розбіжність об'єктної і реляційної моделей *(object-relational impedance mismatch)*. Це не означає, що MongoDB - погане рішення для Ruby, навпаки. Швидше я думаю, що більшість Ruby-розробників бачать MongoDB як невелике покращення, у той час як розробники, які пишуть на C# або Java, бачать прірву, яка розділяє MongoDB і їх підхід до маніпулювання даними. 

Подумайте про це з точки зору розробника драйверів. Вам треба зберегти об'єкт? Серіалізіруйте його в JSON (насправді в BSON, але це майже одне і те ж) і відправте в MongoDB. Немає ніякого маппінгу властивостей або типів. Ця простота виразно повинна підходити вам, як кінцевому розробнику.

### Record ###
Область, для якої MongoDB особливо підходить, - це логування. Є два аспекти MongoDB, які роблять запис швидким. По-перше, можна відправити команду запису і продовжити роботу, не очікуючи її повернення і дійсного закінчення запису. По-друге, з появою у версії 1.8 журналювання і деяких покращень, які зроблені у версії 2.0, стало можливим контролювати поведінку запису з урахуванням цілісності даних. Ці параметри, на додаток до того, скільки серверів повинні отримати ваші дані, перш ніж запис буде вважатися успішною, налаштовуються на рівні окремого запису, що дає вам більший контроль над виконанням запису даних і їх довговічністю.

Крім зазначених факторів продуктивності, при логіюванні якраз може виявитися корисною гнучка структура даних. Нарешті, в MongoDB є таке поняття, як [обмежена колекція](http://ru.wiki.mongodb.org/display/DOCS/Capped+Collections) *(capped collection)*. До цих пір ми створювали звичайні колекції. Ми можемо створити обмежену колекцію за допомогою команди `db.createCollection`, включивши прапорець `capped`:

	// Обмежуємо розмір колекції до 1 мегабайта
	db.createCollection('logs', {capped: true, size: 1048576})

Коли наша обмежена колекція досягне розміру в 1 мегабайт, старі документи почнуть автоматично видалятися. Можна також задати не розмір колекції, а максимальну кількість документів, за допомогою опції `max`. У обмежених колекцій є ряд цікавих властивостей. Наприклад, можна змінити документ, але він не може вирости в розмірі. Також зберігається порядок вставки, так що не потрібно додавати додаткове поле для хронологічного сортування.

Також варто зауважити, що якщо потрібно з'ясувати, чи викликав ваш запис які-небудь помилки (як, наприклад, у вже згаданому випадку, коли ми не чекаємо його завершення), можна просто виконати наступну команду: `db.getLastError()`. Більшість драйверів інкапсулюють цю функцію, як *безпечний запис*, наприклад, можна вказати `{: safe => true}` другим параметром методу `insert`.

### Стійкість ###
MongoDB до версії 1.8 не забезпечувала стійкості даних на одному сервері. Так, відмова сервера могла призвести до втрати даних. Рішення завжди складалося в роботі MongoDB на декількох серверах (MongoDB підтримує реплікацію). Однією з найважливіших функцій, доданих в MongoDB 1.8, стало журналювання. Щоб включити його, додайте `journal = true` у файл `mongodb.config`, створений нами при першій налаштуванні MongoDB (і перезапустіть сервер, щоб зміни вступили в дію). Швидше за все, журналювання вам знадобиться (в наступних релізах за замовчуванням воно буде включено). Незважаючи на деяке збільшення продуктивності, яке може бути досягнуто при відключенні журналювання, можливий певний ризик. (З іншого боку, бувають додатки, які допускають втрату деяких даних).

Стійкість даних згадується тут тому, що багато сил було витрачено для того, щоб домогтися її в межах одного сервера. Ви рано чи пізно знайдете в Google згадки про ненадійність Mongo як сховища. Однак ця інформація вже застаріла.

### Повнотекстовий пошук ###
У майбутніх релізах, сподіваюся, повнотекстовий пошук прийде в MongoDB. З підтримкою для масивів базовий повнотекстовий пошук буде досить просто застосовувати. Для потужних додатків швидше за все знадобиться використовувати щось на зразок Lucene або Solr. Звичайно також це справедливо і для реляційних баз даних.

### Транзакції ###
MongoDB не підтримує транзакцій. Є дві альтернативи: одна - чудова, але обмежена у використанні, а інша - громіздка, але гнучка.

Перша альтернатива - це множина атомарних операцій. Вони прекрасні до тих пір, поки вирішують вашу проблему. Ми вже бачили деякі з них, наприклад, `$inc` і `$set`. Також існують команди на кшталт `findAndModify` які можуть оновлювати або видаляти документ і автоматично його повертати.

Друга альтернатива - коли атомарних операцій не вистачає - це двофазний коміт. Двофазний коміт в порівнянні з транзакціями - це приблизно те ж саме, що ручне розрулювання запитів в порівнянні з JOIN-ами. Це незалежне від сховища рішення, яке ви здійснюєте в коді.  Також двофазний коміт досить поширений в реляційному світі, коли потрібно забезпечити транзакції в межах декількох баз даних. На сайті MongoDB є [приклад](http://ru.wiki.mongodb.org/display/DOCS/two-phase+commit), який ілюструє найбільш поширений сценарій (переказ грошових коштів). Загальна ідея полягає в тому, що ви зберігаєте стан транзакції усередині оновлюваного документа і проходите кроки init-pending-commit/rollback вручну. 

Підтримка вкладених документів і безструктурна архітектура MongoDB роблять двофазні коміти не такими вже страшними, але все одно це складний процес, особливо для тих, хто вперше з цим стикається. 

### Обробка даних ###
Для більшості задач обробки даних MongoDB використовує MapReduce. Є, звичайно, деякі [базові агрегуючі функції](http://ru.wiki.mongodb.org/display/DOCS/Aggregation), але для чого-небудь серйозного вам знадобиться MapReduce. У наступному розділі ми розглянемо MapReduce більш детально. Зараз можете вважати його дуже потужним і альтернативним варіантом `group by` (що, втім, буде применшенням його можливостей). Одна з переваг MapReduce в тому, що для роботи з великими обсягами даних він може виконуватися паралельно. Однак реалізація MongoDB базується на JavaScript, який сам по собі однопотоковий. Що з цього випливає? Для обробки великих даних вам, швидше за все, доведеться покладатися на щось інше, наприклад, на Hadoop. На щастя, ці дві системи настільки доповнюють один одного, що існує [MongoDB адаптер для Hadoop](https://github.com/mongodb/mongo-hadoop).

Звичайно, розпаралелювання обробки даних не є однозначним предметом переваги реляційних баз даних. У майбутніх релізах MongoDB планується поліпшити обробку величезних обсягів даних.

### Геопросторові дані ###
Особливо потужною функцією MongoDB є її підтримка геопросторових індексів. Це дозволяє зберігати x- і y-координати у документів і потім знаходити документи поблизу (`$near`) певних координат, або всередині (`$within`) прямокутника або кола. Це легше зрозуміти візуально, тому я раджу подивитися [п'ятихвилинний практикум з геопросторових функцій MongoDB](http://tutorial.mongly.com/geo/index), якщо хочете поглибити свої знання.

### Інструментарій і зрілість ###
Ви вже, напевно, знаєте - MongoDB значно молодша більшості реляційних баз даних. Це обов'язково потрібно враховувати. Наскільки велику роль це відіграє - залежить від ваших завдань та їх реалізації. Не можна ігнорувати той факт, що MongoDB - молода технологія, і доступний інструментарій ще не дуже різноманітний (втім, інструментарій зрілих реляційних баз даних буває часом просто жахливий). Наприклад, відсутність підтримки десяткових чисел з плаваючою комою, очевидно, буде проблемою (хоча і не обов'язково непереборною) для систем, що мають справу з грошима.

Є і позитивні сторони: для більшості мов написані хороші драйвери, протокол - сучасний і простий, розробка рухається досить швидко. MongoDB використовується на робочих серверах у багатьох компаній, так що хвилювання про зрілість технології скоро підуть в історію.

# # # У цій главі # # #
Ідея цієї глави в тому, що MongoDB в більшості випадків здатна стати заміною реляційній базі даних. Вона набагато простіша і зрозуміліша; швидше працює і має менше обмежень для розробників додатків. Відсутність транзакцій може викликати серйозну і справедливу заклопотаність. Однак, коли запитують *яке місце займає MongoDB в екосистемі сучасних механізмів зберігання?*, Відповідь проста: **строго посередині**.

\ Clearpage

## Глава 6 - MapReduce ##
MapReduce - це підхід до обробки даних, який має два серйозних переваги в порівнянні з традиційними рішеннями. Перша і найголовніша перевага - це продуктивність. Теоретично MapReduce може бути распараллелений, що дозволяє обробляти величезні масиви даних на багатьох ядерах/процесорах/машинах. Як уже згадувалося, це поки не є перевагою MongoDB. Другою перевагою MapReduce є можливість описувати обробку даних нормальним кодом. У порівнянні з тим, що можна зробити за допомогою SQL, можливості коду всередині MapReduce набагато багатша і дозволяють розширити рамки можливого навіть без використання спеціалізованих рішень.

MapReduce - це шаблон, який стрімко набуває популярності, і вже можна використовувати майже скрізь; реалізації вже маються в C#, Ruby, Java, Python. Повинен попередити, що на перший погляд він може здатися дуже незвичним і складним. Не турбуйтеся, не поспішайте і поекспериментуйте з ним самостійно. Це варто того - не важливо, використовуєте ви MongoDB чи ні.

### Теорія і практика ###
MapReduce - процес двоступінчастий. Спочатку робиться map *(відображення)*, потім - reduce *(згортка)*. На етапі відображення вхідні документи трансформуються *(map)* і породжують *(emit)* пари ключ => значення (як ключ, так і значення можуть бути складними). При згортці *(reduce)* на вході виходить ключ і масив значень, породжених для цього ключа, а на виході - фінальний результат. Подивимося на обидва етапи і на їх вихідні дані.

У нашому прикладі ми будемо генерувати звіт про денну кількістю хітів для будь-якого ресурсу (наприклад, веб-сторінки). Це *hello world* для MapReduce. Для наших завдань ми скористаємося колекцією `hits` з двома полями: `resource` і `date`. Бажаний результат - це звіт у розрізі ресурсу, року, місяця, дня і кількості. 

Нехай в `hits` лежать наступні дані:

	resource date
	index Jan 20 2010 4:30
	index Jan 20 2010 5:30
	about Jan 20 2010 6:00
	index Jan 20 2010 7:00
	about Jan 21 2010 8:00
	about Jan 21 2010 8:30
	index Jan 21 2010 8:30
	about Jan 21 2010 9:00
	index Jan 21 2010 9:30
	index Jan 22 2010 5:00

На виході ми хочемо наступний результат:

	resource  year   month   day   count
	index     2010   1       20    3
	about     2010   1       20    1
	about     2010   1       21    3
	index     2010   1       21    2
	index     2010   1       22    1

(Чарівність даного підходу полягає в зберіганні результатів; звіти генеруються швидко і зростання даних контролюється - для одного ресурсу в день буде додаватися максимум один документ.)

Давайте тепер зосередимося на розумінні концепції. В кінці глави в якості прикладу будуть приведені дані і код.

Першим ділом розглянемо функцію відображення. Завдання функції відображення - породити значення, які в подальшому будуть використовуватись при згортці. Породжувати значення можна нуль або більше разів. У нашому випадку - як найчастіше буває - це завжди буде робитися один раз. Уявіть, що map у циклі перебирає кожен документ в колекції `hits`. Для кожного документа ми повинні породити *ключ*, що складається з ресурсу, року, місяця і дня, і примітивне *значення* - одиницю:

	function() {
		var key = {
			resource: this.resource, 
			year: this.date.getFullYear(), 
			month: this.date.getMonth(), 
			day: this.date.getDate()
		};
	emit(key, {count: 1}); 
	}

`This` посилається на поточний аналізований документ. Сподіваюся, результуючі дані прояснять для вас картину того, що відбувається. При використанні наших тестових даних, в результаті отримаємо:

	{resource: 'index', year: 2010, month: 0, day: 20} => [{count: 1}, {count: 1}, {count: 1}]
	{resource: 'about', year: 2010, month: 0, day: 20} => [{count: 1}]
	{resource: 'about', year: 2010, month: 0, day: 21} => [{count: 1}, {count: 1}, {count: 1}]
	{resource: 'index', year: 2010, month: 0, day: 21} => [{count: 1}, {count: 1}]
	{resource: 'index', year: 2010, month: 0, day: 22} => [{count: 1}]

Розуміння цього проміжного етапу дає ключ до розуміння MapReduce. Породжені дані збираються в масиви за однаковом ключем. .NET і Java розробники можуть розглядати це як тип `IDictionary <object, IList <object>>` (.NET) або `HashMap <Object, ArrayList>` (Java).

Давайте змінимо нашу map-функцію дещо надуманим способом:

	function() {
		var key = {resource: this.resource, year: this.date.getFullYear(), month: this.date.getMonth(), day: this.date.getDate()};
		if (this.resource == 'index' && this.date.getHours() == 4) {
			emit(key, {count: 5});
		} Else {
			emit(key, {count: 1}); 
		}
	}

Перший проміжний результат тепер зміниться на:

	{resource: 'index', year: 2010, month: 0, day: 20} => [{count: 5}, {count: 1}, {count: 1}]

Зверніть увагу, як кожен emit породжує нове значення, яке групується за ключем.

Reduce-функція бере кожне з цих проміжних значень і видає кінцевий результат. Ось так виглядатиме наша функція:

	function(key, values) {
		var sum = 0;
		values.forEach(function(value) {
			sum + = value ['count'];
		});
		return {count: sum};
	};

На виході отримаємо:

	{resource: 'index', year: 2010, month: 0, day: 20} => {count: 3}
	{resource: 'about', year: 2010, month: 0, day: 20} => {count: 1}
	{resource: 'about', year: 2010, month: 0, day: 21} => {count: 3}
	{resource: 'index', year: 2010, month: 0, day: 21} => {count: 2}
	{resource: 'index', year: 2010, month: 0, day: 22} => {count: 1}

Технічно в MongoDB результат має вигляд:

	_id: {resource: 'home', year: 2010, month: 0, day: 20}, value: {count: 3}

Це і є наш кінцевий результат.

Якщо ви були уважні, ви повинні були запитати себе: *чому ми просто не написали `sum = values.length`*? Це було б ефективним підходом, якби ми підсумовували масив одиниць. На ділі reduce не завжди викликається з повним і досконалим набором проміжних даних. Наприклад замість того, щоб бути викликаним з:

	{resource: 'home', year: 2010, month: 0, day: 20} => [{count: 1}, {count: 1}, {count: 1}]

Reduce може бути викликаний з:

	{resource: 'home', year: 2010, month: 0, day: 20} => [{count: 1}, {count: 1}]
	{resource: 'home', year: 2010, month: 0, day: 20} => [{count: 2}, {count: 1}]

Кінцевий результат той же самий (3), однак він виходить трохи різними шляхами. Таким чином, reduce повинен завжди бути ідемпотентним. Тобто, викликаючи reduce кілька разів, ми повинні отримувати такий же результат, що і викликаючи його один раз. 

Ми не станемо розглядати цього тут, однак поширена практика послідовних згорток, коли потрібно виконати складний аналіз. 

### Чиста практика ###
З MongoDB ми викликаємо у колекції команду `mapReduce`. `MapReduce` приймає функцію map, функцію reduce і директиви для результату. В консолі ми можемо створювати і передавати JavaScript функції. З більшості бібліотек ви будете передавати стрічкове представлення функції (яке може мати жахливий вигляд). Спершу давайте створимо набір даних:

	db.hits.insert({resource: 'index', date: new Date(2010, 0, 20, 4, 30)});
	db.hits.insert({resource: 'index', date: new Date(2010, 0, 20, 5, 30)});
	db.hits.insert({resource: 'about', date: new Date(2010, 0, 20, 6, 0)});
	db.hits.insert({resource: 'index', date: new Date(2010, 0, 20, 7, 0)});
	db.hits.insert({resource: 'about', date: new Date(2010, 0, 21, 8, 0)});
	db.hits.insert({resource: 'about', date: new Date(2010, 0, 21, 8, 30)});
	db.hits.insert({resource: 'index', date: new Date(2010, 0, 21, 8, 30)});
	db.hits.insert({resource: 'about', date: new Date(2010, 0, 21, 9, 0)});
	db.hits.insert({resource: 'index', date: new Date(2010, 0, 21, 9, 30)});
	db.hits.insert({resource: 'index', date: new Date(2010, 0, 22, 5, 0)});

Тепер можна створити функції map і reduce (консоль MongoDB дозволяє вводити багаторядкові конструкції):

	var map = function() {
		var key = {resource: this.resource, year: this.date.getFullYear(), month: this.date.getMonth(), day: this.date.getDate()};
		emit(key, {count: 1}); 
	};
	var reduce = function(key, values) {
		var sum = 0;
		values.forEach(function(value) {
			sum + = value ['count'];
		});
		return {count: sum};
	};

Ми виконаємо команду `mapReduce` над колекцією `hits` наступним чином:

	db.hits.mapReduce(map, reduce, {out: {inline: 1}})

Якщо ви виконаєте код, наведений вище, ви побачите очікуваний результат. Встановивши `out` в `inline` ми вказуємо, що `mapReduce` повинен безпосередньо повернути результат в консоль. В даний момент розмір результату обмежений 16 мегабайтами. Замість цього ми могли б написати `{out: 'hit_stats'}`, і результат був би збережений в колекцію `hit_stats`:

	db.hits.mapReduce(map, reduce, {out: 'hit_stats'});
	db.hit_stats.find();

У такому випадку всі існуючі дані з колекції `hit_stats` були б спочатку видалені. Якби ми написали `{out: {merge: 'hit_stats'}}`, існуючі значення за відповідними ключами були б замінені на нові, а інші були б вставлені. І нарешті, можна в `out` використовувати `reduce` функцію - для більш складних випадків. 

Третій параметр приймає додаткові значення - наприклад, можна сортувати, фільтрувати або обмежувати аналізовані дані. Ми також можемо передати метод `finalize`, який застосується до результату поверненим етапом `reduce`.

### У цій главі ###
Це перша глава, в якій ми висвітлили зовсім нову для вас тему. Якщо ви відчуваєте незручності, завжди можна звернутися до інших [засобів агрегування](http://ru.wiki.mongodb.org/display/DOCS/Aggregation) і більш простих сценаріїв. Втім, MapReduce є однією з найбільш важливих функцій MongoDB. Щоб навчитися писати функції map і reduce, необхідно чітко уявляти і розуміти, як виглядають ваші дані і як вони перетворюються по шляху через `map` і `reduce`.

\ Clearpage

## Глава 7 - Продуктивність та інструментарій ##
У цій главі ми торкнемося деяких питань продуктивності, а також розглянемо інструментарій, доступний розробникам MongoDB. Ми не будемо сильно занурюватися в ці теми, але розглянемо найбільш важливі аспекти кожної.

### Індекси ###
На самому початку ми бачили колекцію `system.indexes`, яка містить інформацію про всіх індексах в нашій базі даних. Індекси в MongoDB працюють аналогічним чином до індексів в реляційних базах даних: вони прискорюють вибірку і сортування даних. Індекси створюються за допомогою `ensureIndex`:

	db.unicorns.ensureIndex({name: 1});

І знищуються за допомогою `dropIndex`:

	db.unicorns.dropIndex({name: 1});

Унікальний індекс може бути створений, якщо у другому параметрі встановити `unique` в `true`:

	db.unicorns.ensureIndex({name: 1}, {unique: true});

Можна створювати індекси над вкладеними полями (знову ж, використовуючи точкову нотацію), або над масивами. Також можна створювати складові індекси:

	db.unicorns.ensureIndex({name: 1, vampires: -1});

Порядок вашого індексу (1 для висхідного і -1 для низхідного) не грає ролі у випадку з простим індексом, однак він може бути суттєвим при сортуванні або лімітування із застосуванням складових індексів.

На [сторінці опису індексів](http://ru.wiki.mongodb.org/display/DOCS/Indexes) можна знайти додаткову інформацію.

### Explain ###
Щоб побачити, чи використовуються індекси в ваших запитах, викликайте у курсору метод `explain`:

	db.unicorns.find().explain()

В результаті ми бачимо інформацію, що використовувався `BasicCursor` (тобто не індексований), сканування відбувалося за 12 об'єктами, як багато це часу зайняло, чи застосовувався індекс, і якщо так, то який, а також інші корисні відомості.

Якщо ми змінимо запит так, щоб він використовував індекс, ми побачимо, що використовувався курсор `BtreeCursor`, а також побачимо індекс, використаний при вибірці:

	db.unicorns.find({name: 'Pilot'}).explain()

### Запис без підтвердження ###
Ми вже згадували, що запис даних в MongoDB відбувається без підтвердження. Це може призвести до приросту продуктивності, так само як і до ризику втрати даних в результаті випадкової помилки. Виникає також побічний ефект, що виражається в тому, що коли оновлення або вставка порушують умова унікальності індексу, помилки не відбувається. Щоб дізнатися про виникнення помилки, після останнього запису потрібно викликати `db.getLastError()`. Багато драйверів беруть цю роботу на себе, надаючи можливість *безпечного* запису - часто для цього є спеціальний параметр.

На жаль, консоль не вміє цього робити, і поспостерігати це в консолі буде непросто.

### Шардінг ###
MongoDB підтримує авто-шардінг. Шардінг - це підхід до масштабованості, коли окремі частини даних зберігаються на різних серверах. Примітивний приклад - зберігати дані користувачів, чиє ім'я починається на літери A-M на одному сервері, а решту - на іншому. Можливості шардінга MongoDB значно перевершують даний простий приклад. Розгляд шардінга виходить за межі даної книги, проте ви повинні знати, що він існує, і ви повинні скористатися ним, коли ваші завдання вийдуть за рамки одного сервера.

### Реплікація ###
Реплікація в MongoDB працює аналогічно до реплікації в реляційних базах даних. Записи надсилаються на один сервер - провідний *(master)*, який потім синхронізує свій стан з іншими серверами - відомими *(slave)*. Ви можете дозволити або заборонити читання з ведених серверів, в залежності від того, чи допускається у вашій системі читання неузгоджених даних. Якщо ведучий сервер падає, один з ведених може взяти на себе роль ведучого. Реплікація MongoDB також виходить за межі даної книги.

Хоча реплікація збільшує продуктивність читання, роблячи його розподіленим, основна її мета - збільшення надійності. Типовим підходом є поєднання реплікації і шардінга. Наприклад, кожен шард може складатися з ведучого і веденого серверів. (Технічно, вам також знадобиться арбітр, щоб вирішити конфлікт, коли два ведених сервери намагаються оголосити себе ведучими. Але арбітр споживає дуже мало ресурсів і може бути використаний для декількох шардів відразу.)

### Статистика ###
Статистику бази даних можна отримати за допомогою виклику `db.stats()`. В основному інформація стосується розміру вашої бази даних. Також можна отримати статистику колекції, наприклад `unicorns`, за допомогою виклику `db.unicorns.stats()`. Велика частина одержуваної інформації, знову ж таки, стосується розмірів колекції.

### Веб-інтерфейс ###
Коли `mongod` запускається, в консолі з'являється, серед інших, стрічка з посиланням на адміністративний веб-інтерфейс. Ви можете отримати до нього доступ, зайшовши в браузері на <http://localhost:28017/>. Щоб отримати від нього максимальну віддачу, можете додати `rest = true` в конфігураційний файл і перезапустити процес `mongod`. Веб-інтерфейс дає багато цікавої інформації про поточний стан сервера.

### Профайлер ###
Профайлер MongoDB можна включити за допомогою наступного виклику:

	db.setProfilingLevel(2);

З увімкненим профайлером можна запустити команду:

	db.unicorns.find({weight: {$gt: 600}});

І звернутися до профайлера:

	db.system.profile.find()

У результаті ми побачимо, що і коли запускалося, як багато документів сканувалось, як багато даних було повернуто.

Можна вимкнути профайлер, повторно викликавши `setProfileLevel`, тільки передавши `0` в якості аргументу. Можна також передати `1` для профілювання запитів, що виконуються довше 100 мілісекунд. Також, можна другим параметром передати час в мілісекундах:

	// Профілювати все, що займає більш 1 секунди
	db.setProfilingLevel(1, 1000);

### Резервне копіювання і відновлення ###
У папці `bin` MongoDB є утиліта `mongodump`. Після виконання `mongodump` відбудеться підключення до `localhost` і резервне копіювання всіх баз даних в підпапку `dump`. Можна набрати `mongodump - help` і побачити додаткові опції. Поширені опції: `- db DBNAME` для резервного копіювання тільки зазначеної бази даних і `- collection COLLECTIONAME` для резервного копіювання тільки зазначеної колекції. Після цього можна використовувати `mongorestore`, розташований в тій же папці `bin`, щоб відновити базу даних з попередньо зробленої резервної копії. Тут також можна вказати `- db` і `- collection`, щоб відновити тільки зазначені базу даних і колекцію. 

Наприклад, щоб зробити резервну копію бази даних `learn` в папку `backup`, ми повинні виконати (зрозуміло не в консолі самої MongoDB, а просто в консолі операційної системи):

	mongodump --db learn --out backup

Щоб відновити тільки колекцію `unicorns` ми повинні зробити наступне:

	mongorestore --collection unicorns backup/learn/unicorns.bson

Також, варто згадати, що є дві утиліти `mongoexport` і `mongoimport`, призначені для експорту та імпорту даних у вигляді JSON і CSV. Наприклад, можна отримати результат у вигляді JSON наступним чином:

	mongoexport -db learn-collection unicorns

і CSV:

	mongoexport --db learn-collection unicorns --csv-fields name, weight, vampires

Майте на увазі, що `mongoexport` і `mongoimport` не можуть повністю відображати ваші дані. Тільки `mongodump` і `mongorestore` повинні використовуватися для справжнього резервного копіювання.

### У цій главі ###
У цій главі ми розглянули різні команди, інструменти та нюанси продуктивності MongoDB. Ми торкнулися не всіх тем, однак розглянули найбільш поширені. Індексування в MongoDB схоже на індексування в реляційних базах даних, те ж стосується більшості інструментарію. Однак у MongoDB користуватися всім набагато простіше.

\ Clearpage

## Висновок ##
Тепер у вас достатньо інформації для того, щоб почати користуватися MongoDB в реальних проектах. MongoDB має в собі ще безліч аспектів, про які не йшлося в книзі, однак вашої найближчим завданням буде скористатися отриманими знаннями та почати вивчати драйвер, який ви будете використовувати. На [сайті MongoDB](http://www.mongodb.com/) є багато корисної інформації. В офіційній [групі MongoDB](http://groups.google.com/group/mongodb-user) можна отримати відповіді на безліч питань.

NoSQL створюється не тільки з необхідності, але ще і з інтересу до пошуку нових підходів. Це означає, що ми знаходимося на передовому фронті, і успіх може прийти тільки до тих, хто не опускає руки. Ось так, я думаю, і потрібно жити в нашій з вами професії.